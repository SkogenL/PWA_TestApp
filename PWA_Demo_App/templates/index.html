<!DOCTYPE html>
<html class="" lang="en">
    {% include "header.html" %}
    <nav>
      <div class="tab">
        <ul>
          <li><strong id="navPageName">PWA Testing App</strong></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'MediaCapture')">Media Capture</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'Geolocation')">Geolocation</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'Notifications')">Notifications</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'Barcodes')">Barcodes/QR</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'MultiTouch')">Multi Touch</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'Motion')">Motion</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'ViewTransitions')">View Transitions</button></li>
          <li><button class="tablinks" onclick="selectFeature(event, 'WakeLock')">Wake Lock</button></li>
        </ul>
      </div>
  </nav>
  <body>
      <main>
          <div class="tabcontent" id="MediaCapture">
            <p>
              Media capture types:
              <p>
                <label for="soundFile">What does your voice sound like?:</label>
                <input type="file" id="soundFile" capture="user" accept="audio/*" />
              </p>
              <p>
                <label for="videoFile">Upload a video:</label>
                <input type="file" id="videoFile" capture="environment" accept="video/*" />
              </p>
              <p>
                <label for="imageFile1">Upload a photo of yourself (opens file upload):</label>
                <input type="file" id="imageFile1" accept="image/*" />
              </p> 
              <p>
                <label for="imageFile2">Upload a photo of yourself (opens camera on mobile):</label>
                <input type="file" id="imageFile2" capture="user" accept="image/*" />
              </p> 
              Note: 
            </p>           
          </div>
          <div class="tabcontent" id="Geolocation">
            <button id="find-me">Show my location</button><br />
            <p id="status"></p>
            <a id="map-link" target="_blank"></a>
          </div>
          <div class="tabcontent" id="Notifications">
            Send a notification:
            <button id="notifButton">Send</button></br>
            Note: Not available on Firefox iOS, and on Safari the site must be added to home screen.
          </div>
          <div class="tabcontent" id="Barcodes">
            Barcodes
          </div>
          <div class="tabcontent" id="MultiTouch">
            Touch Events and multi-touch</br>
            <canvas id="canvas" width="600" height="600" style="border:solid black 1px;">
              Your browser does not support canvas elements.
            </canvas>
            <br />
            Log:
            <pre id="log" style="border: 1px solid #ccc;"></pre>              
          </div>
          <div class="tabcontent" id="Motion">
            Motion
          </div>
          <div class="tabcontent" id="ViewTransitions">
            ViewTransitions
          </div>
          <div class="tabcontent" id="WakeLock">
            <p id="wakeStatus"></p>
            <input type="checkbox" id="wakeCheckbox">
            <label for="wakeCheckbox">Prevent device from going to sleep.</label>
          </div>
      </main>
      <p>This is a simple web app created to practice implementing Progressive Web Apps (PWA), and other web technologies.</p>
  </body>
  <script type=module>
      import {handleStart, handleMove, handleCancel, handleEnd, log, geoFindMe,
        notificationButton} from "/static/main.js";
      function startup() {
          const el = document.getElementById("canvas");
          el.addEventListener("touchstart", handleStart);
          el.addEventListener("touchend", handleEnd);
          el.addEventListener("touchcancel", handleCancel);
          el.addEventListener("touchmove", handleMove);
          log("Initialized.");
        }
        
      document.addEventListener("DOMContentLoaded", startup);
        
      // Geolocation setup
      document.querySelector("#find-me").addEventListener("click", geoFindMe);
      document.querySelector("#find-me").addEventListener("tap", geoFindMe);
      // Notification setup
      document.querySelector("#notifButton").addEventListener("click", notificationButton);
      document.querySelector("#notifButton").addEventListener("tap", notificationButton);
      // Wake lock setup
      const wakeBox = document.querySelector("#wakeCheckbox");
      if ("wakeLock" in navigator) {
        isSupported = true;
        document.querySelector("#wakeStatus").textContent = "Screen Wake Lock API supported!";
      } else {
        wakeBox.disabled = true;
        document.querySelector("#wakeStatus").textContent = "Wake lock is not supported by this browser.";
      }
      
      
      
      
      /**function geoFindMe() {
        const status = document.querySelector("#status");
        const mapLink = document.querySelector("#map-link");
      
        mapLink.href = "";
        mapLink.textContent = "";
      
        function success(position) {
          const latitude = position.coords.latitude;
          const longitude = position.coords.longitude;
      
          status.textContent = "";
          mapLink.href = `https://www.openstreetmap.org/#map=18/${latitude}/${longitude}`;
          mapLink.textContent = `Latitude: ${latitude} °, Longitude: ${longitude} °`;
        }
      
        function error() {
          status.textContent = "Unable to retrieve your location";
        }
      
        if (!navigator.geolocation) {
          status.textContent = "Geolocation is not supported by your browser";
        } else {
          status.textContent = "Locating…";
          navigator.geolocation.getCurrentPosition(success, error);
        }
    }
    
    // Notification functions
    const serviceReg = await navigator.serviceWorker.getRegistration();
    const notificationButton = async () => {
        const img = "/static/pwa_ico.png";
        const text = `Hello, here's a quick demonstration of how notifications can work`;
        // Browser support check
        if (!("Notification" in window)) {
            alert("This browser does not support notifications.");
            return;
        }
        //const notifBtn = document.getElementsByClassName("notifButton");
        // If permission granted, send notification, if not, request it.
        if(Notification.permission === 'granted') {
            if(!serviceReg === false && 'showNotification' in serviceReg) {
                serviceReg.showNotification("Test Notif", {body:text, icon:img});
            }
            else {
                new Notification("Test Notif", {body:text, icon:img});
            }
            return;
        }
        if(Notification.permission !== 'denied') {
            const result = await Notification.requestPermission();
            if(result === 'granted') {
                if(!serviceReg === false && 'showNotification' in serviceReg) {
                    serviceReg.showNotification("Test Notif", {body:text, icon:img});
                }
                else {
                    new Notification("Test Notif", {body:text, icon:img});
                }
            }
        }
    }
      
    
    // Touch canvas functions
    
    const ongoingTouches = [];
    
    function handleStart(evt) {
        evt.preventDefault();
        log("touchstart.");
        const el = document.getElementById("canvas");
        const ctx = el.getContext("2d");
        const touches = evt.changedTouches;
      
        for (let i = 0; i < touches.length; i++) {
          log(`touchstart: ${i}.`);
          ongoingTouches.push(copyTouch(touches[i]));
          const color = colorForTouch(touches[i]);
          log(`color of touch with id ${touches[i].identifier} = ${color}`);
          ctx.beginPath();
          ctx.arc(touches[i].pageX, touches[i].pageY, 4, 0, 2 * Math.PI, false); // a circle at the start
          ctx.fillStyle = color;
          ctx.fill();
        }
    }
    
    function handleMove(evt) {
        evt.preventDefault();
        const el = document.getElementById("canvas");
        const ctx = el.getContext("2d");
        const touches = evt.changedTouches;
      
        for (let i = 0; i < touches.length; i++) {
          const color = colorForTouch(touches[i]);
          const idx = ongoingTouchIndexById(touches[i].identifier);
      
          if (idx >= 0) {
            log(`continuing touch ${idx}`);
            ctx.beginPath();
            log(
              `ctx.moveTo( ${ongoingTouches[idx].pageX}, ${ongoingTouches[idx].pageY} );`,
            );
            ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
            log(`ctx.lineTo( ${touches[i].pageX}, ${touches[i].pageY} );`);
            ctx.lineTo(touches[i].pageX, touches[i].pageY);
            ctx.lineWidth = 4;
            ctx.strokeStyle = color;
            ctx.stroke();
      
            ongoingTouches.splice(idx, 1, copyTouch(touches[i])); // swap in the new touch record
          } else {
            log("can't figure out which touch to continue");
          }
        }
      }
    
      function handleEnd(evt) {
        evt.preventDefault();
        log("touchend");
        const el = document.getElementById("canvas");
        const ctx = el.getContext("2d");
        const touches = evt.changedTouches;
      
        for (let i = 0; i < touches.length; i++) {
          const color = colorForTouch(touches[i]);
          let idx = ongoingTouchIndexById(touches[i].identifier);
      
          if (idx >= 0) {
            ctx.lineWidth = 4;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
            ctx.lineTo(touches[i].pageX, touches[i].pageY);
            ctx.fillRect(touches[i].pageX - 4, touches[i].pageY - 4, 8, 8); // and a square at the end
            ongoingTouches.splice(idx, 1); // remove it; we're done
          } else {
            log("can't figure out which touch to end");
          }
        }
      }
    
      function colorForTouch(touch) {
        let r = touch.identifier % 16;
        let g = Math.floor(touch.identifier / 3) % 16;
        let b = Math.floor(touch.identifier / 7) % 16;
        r = r.toString(16); // make it a hex digit
        g = g.toString(16); // make it a hex digit
        b = b.toString(16); // make it a hex digit
        const color = `#${r}${g}${b}`;
        return color;
      }
      
    
      function handleCancel(evt) {
        evt.preventDefault();
        log("touchcancel.");
        const touches = evt.changedTouches;
      
        for (let i = 0; i < touches.length; i++) {
          let idx = ongoingTouchIndexById(touches[i].identifier);
          ongoingTouches.splice(idx, 1); // remove it; we're done
        }
      }
    
      function copyTouch({ identifier, pageX, pageY }) {
        return { identifier, pageX, pageY };
      }
            
      function ongoingTouchIndexById(idToFind) {
        for (let i = 0; i < ongoingTouches.length; i++) {
          const id = ongoingTouches[i].identifier;
      
          if (id === idToFind) {
            return i;
          }
        }
        return -1; // not found
      }
      function log(msg) {
        const container = document.getElementById("log");
        container.textContent = `${msg} \n${container.textContent}`;
      }
      
      */
  </script>
</html> 